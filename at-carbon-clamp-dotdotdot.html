/*
* Copyright (c) 2014 adenin TECHNOLOGIES. All rights reserved.
* This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
*
* based on Clamp.js 0.5.1
* Copyright 2011-2013, Joseph Schmitt http://joe.sh
* Released under the WTFPL license
* http://sam.zoy.org/wtfpl/
*/
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-core-theme/at-core-theme.html">

<script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="js/jquery.dotdotdot.js"></script>

<dom-module id="at-carbon-clamp">
    <style>
      :host {
        position: relative;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        display: block;
      }

      #textPara {
        -webkit-transform: translateZ(0); /* hack to force Chrome to handle divs outside visible viewport correctly */
      }
    </style>
    <template>
        <at-core-theme></at-core-theme>
        <div id="clampWrapper" style="height:100%">
            <div id="textPara"></div>
        </div>
        <content></content>
    </template>
</dom-module>
<script>
    Polymer({
        is:'at-carbon-clamp',
        _scopeCssViaAttr: true,
        properties: {
            text: {
                type: String,
                value: '', 
                reflect: true
            },
            lines: { 
                type: Number,
                value: 1, 
                reflect: true
            }
        },
          
        observers:[
            'propChanged(text, lines)'
        ],
        
        propChanged: function(){
            if(!this._afterReady){
                return;
            }
            
            this.clampText();
        },
          
        attached: function () {
            var that = this;
            window.addEventListener('resize', function (event) {
                that.clampText();
            }.bind(this));
        },
        
        ready: function () {
            this._afterReady = true; //Flag that should fix issue of properties triggering observer method before ready state

            var innerText = this.textContent.slice().trim();
            if(( this.text === undefined || this.text.length == 0) && (innerText.length > 0)){
                this.text = innerText;                
                for(var i=0; i<this.childNodes.length; i++)//Remove only text node from this.textContent
                {
                    if(this.childNodes[i].nodeType==3)//TEXT_NODE
                    {
                        this.removeChild(this.childNodes[i]);
                        i--;
                    }
                }
                
            }
            
            this.clampText();
            
        },
        
        clampText: function () {
           this.debounce('clampText', function(){
                this.$.textPara.style.width = '100%';
                this.$.textPara.textContent = this.text;
                
                if (this.lines === 1) {
                    this.$.textPara.style.textOverflow = 'ellipsis';
                    this.$.textPara.style.whiteSpace = 'nowrap';
                    this.$.textPara.style.overflow = 'hidden';
                } else {
                    //Fix for non chrome browsers
                    var is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
                    var lineNumber = is_chrome? this.lines: this.lines + 1;
                    
                    var wrapperHeight = this.getLineHeight(this.$.textPara) * lineNumber;
                    $(this).height(wrapperHeight);
                    $(this).dotdotdot();
                    
                    //$(this).dotdotdot({ height:wrapperHeight});
                }
            }, 50);
        },

       
        
        // UTILITY FUNCTIONS __________________________________________________________
        
        /**
         * Return the current style for an element.
         * @param {HTMLElement} elem The element to compute.
         * @param {string} prop The style property.
         * @returns {number}
         */
        computeStyle: function (elem, prop) {
            if (!window.getComputedStyle) {
                window.getComputedStyle = function (el, pseudo) {
                    this.el = el;
                    this.getPropertyValue = function (prop) {
                        var re = /(\-([a-z]){1})/g;
                        if (prop == 'float') prop = 'styleFloat';
                        if (re.test(prop)) {
                            prop = prop.replace(re, function () {
                                return arguments[2].toUpperCase();
                            });
                        }
                        return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;
                    }
                    return this;
                }
            }
            
            return window.getComputedStyle(elem, null).getPropertyValue(prop);
        },
        
        /**
         * Returns the line-height of an element as an integer.
         */
        getLineHeight: function (elem) {
            var lh = this.computeStyle(elem, 'line-height');
            if (lh == 'normal') {
                // Normal line heights vary from browser to browser. The spec recommends
                // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.
                lh = parseInt(this.computeStyle(elem, 'font-size')) * 1.1;
            }
            return parseInt(lh);
        }
    });
</script>
