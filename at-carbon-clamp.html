/*
* Copyright (c) 2014 adenin TECHNOLOGIES. All rights reserved.
* This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
*
* based on Clamp.js 0.5.1
* Copyright 2011-2013, Joseph Schmitt http://joe.sh
* Released under the WTFPL license
* http://sam.zoy.org/wtfpl/
*/
<link rel="import" href="../at-core-theme/at-core-theme.html">
<dom-module id="at-carbon-clamp">
    <style>
      :host {
        position: relative;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        display: block;
      }

      #textPara {
        -webkit-transform: translateZ(0); /* hack to force Chrome to handle divs outside visible viewport correctly */
      }
    </style>
    <template>
        <at-core-theme></at-core-theme>
        <div id="clampWrapper" style="height:100%">
            <div id="textPara"></div>
        </div>
        <content></content>
    </template>
</dom-module>
<script>
    Polymer({
        is:'at-carbon-clamp',
        properties: {
            text: {
                type: String,
                value: '', 
                reflect: true ,
                observer:'propChanged'
            },
            lines: { 
                type: Number,
                value: 1, 
                reflect: true,
                observer:'propChanged'
            }
        },
          
        options: new Object(),
//        splitOnChars: ['.', '-', '–', '—', ' '], //Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).
        splitOnChars : /(?:(?:\s+)|(?:\.+)|(?:-+)|(?:–+)|(?:—+)|(?:,+))/, //Regex for text splitting on defined characters
        chunks: null,
        lastChunk: null,
        element: null,
        
        propChanged: function(){
            if(!this._afterReady){
                return;
            }
            
            this.clampText();
        },
          
        attached: function () {
            var that = this;
            window.addEventListener('resize', function (event) {
                that.clampText();
            }.bind(this));
        },
        
        ready: function () {
            this._afterReady = true; //Flag that should fix issue of properties triggering observer method before ready state
            
            this.clampText();
        },
        
        clampText: function () {
            this.debounce('clamp', function(){
                this.$.textPara.style.width = '100%';
                if (this.lines === 1) {
                    this.$.textPara.textContent = this.text;
                    this.$.textPara.style.textOverflow = 'ellipsis';
                    this.$.textPara.style.whiteSpace = 'nowrap';
                    this.$.textPara.style.overflow = 'hidden';
                } else {
                    this.clamp();
                }
            }, 50);
        },

        clamp: function () {
            options = {
                    clamp: this.lines || 2,
                    animate: false,
                    truncationChar: '…'
                };
            
            this.reset();
            this.element = this.$.textPara;
                
            var originalText = this.element.innerHTML,
                clampValue = options.clamp,
                isCSSValue = clampValue.indexOf && (clampValue.indexOf('px') > -1 || clampValue.indexOf('em') > -1);
                
            // CONSTRUCTOR ________________________________________________________________
            if (clampValue == 'auto') {
                clampValue = this.getMaxLines(this.element);
            }
            else if (isCSSValue) {
                clampValue = this.getMaxLines(this.element, parseInt(clampValue));
            }

            var clampedText;
            var height = this.getMaxHeight(clampValue, this.element);
            
            this.element.parentNode.style.textOverflow = 'ellipsis';
            this.element.parentNode.style.overflow = 'hidden';
            this.element.parentNode.style.height = height + "px";
            
            if(height < this.element.clientHeight){
                clampedText = this.truncate(this.getLastChild(this.element), height);
            }
            this.element.parentNode.style.height = "";
            
            return {
                'original': originalText,
                'clamped': clampedText
            }
        },
        
        // UTILITY FUNCTIONS __________________________________________________________
        
        /**
         * Return the current style for an element.
         * @param {HTMLElement} elem The element to compute.
         * @param {string} prop The style property.
         * @returns {number}
         */
        computeStyle: function (elem, prop) {
            if (!window.getComputedStyle) {
                window.getComputedStyle = function (el, pseudo) {
                    this.el = el;
                    this.getPropertyValue = function (prop) {
                        var re = /(\-([a-z]){1})/g;
                        if (prop == 'float') prop = 'styleFloat';
                        if (re.test(prop)) {
                            prop = prop.replace(re, function () {
                                return arguments[2].toUpperCase();
                            });
                        }
                        return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;
                    }
                    return this;
                }
            }
            
            var propValue = window.getComputedStyle(elem, null).getPropertyValue(prop);
            console.log("lvl1: " + propValue);
                        
            return propValue;
        },
        
        /**
         * Returns the maximum height a given element should have based on the line-
         * height of the text and the given clamp value.
         */
        getMaxHeight: function (clmp, elem) {
            var lineHeight = this.getLineHeight(elem);
            var result = lineHeight * clmp;
            if (window.chrome !== 'undefined') {
                result += 1;
            }
            return result;
        },
        
        /**
         * Returns the maximum number of lines of text that should be rendered based
         * on the current height of the element and the line-height of the text.
         */
        getMaxLines: function (elem, height) {
            var availHeight = height || elem.clientHeight,
                lineHeight = this.getLineHeight(elem);

            return Math.max(Math.floor(availHeight / lineHeight), 0);
        },
        
        /**
         * Returns the line-height of an element as an integer.
         */
        getLineHeight: function (elem) {
            var lh = this.computeStyle(elem, 'line-height');
            if (lh == 'normal') {
                // Normal line heights vary from browser to browser. The spec recommends
                // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.
                lh = parseInt(this.computeStyle(elem, 'font-size')) * 1.2;
                console.log("lh: " + lh);
            }
            return parseInt(lh);
        },
        
        /**
         * Gets an element's last child. That may be another node or a node's contents.
         */
        getLastChild: function (elem) {
            //Current element has children, need to go deeper and get last child as a text node            
            if (Polymer.dom(elem.lastChild).childNodes && Polymer.dom(elem.lastChild).childNodes.length > 0) {
                return this.getLastChild(Array.prototype.slice.call(elem.children).pop());
            }
            //This is the absolute last child, a text node, but something's wrong with it. Remove it and keep trying
            else if (!elem.lastChild || !elem.lastChild.nodeValue || elem.lastChild.nodeValue == '' || elem.lastChild.nodeValue == options.truncationChar) {
                elem.lastChild.parentNode.removeChild(elem.lastChild);
                return this.getLastChild(this.element);
            }
            //This is the last child we want, return it
            else {
                return elem.lastChild;
            }
        },
        
        /**
         * Removes one character at a time from the text until its width or
         * height is beneath the passed-in max param.
         */
        truncate: function (target, maxHeight) {
            if (!maxHeight) { return; }
            
            var nodeValue = target.nodeValue.replace(options.truncationChar, ' ');
            
            //Grab the next chunks
            if (!this.chunks) {
                this.chunks = nodeValue.split(this.splitOnChars);
            }

            //If there are chunks left to remove, remove the last one and see if
            // the nodeValue fits.
            if (this.chunks.length > 1) {
                // console.log('chunks', this.chunks);
                this.lastChunk = this.chunks.pop();
                // console.log('lastChunk', this.lastChunk);
                //this.applyEllipsis(target, this.chunks.join(" "));
            }
            //No more chunks can be removed using this character
            else {
                this.chunks = null;
            }

            //Search produced valid chunks
            if (this.chunks) {
                //It fits
                if (this.element.clientHeight <= maxHeight) {
                    //There's still more characters to try splitting on, not quite done yet
                    if (this.splitOnChars.length >= 0) {
                        this.applyEllipsis(target, this.chunks.join(splitChar) + splitChar + this.lastChunk);
                        this.chunks = null;
                    }
                    //Finished!
                    else {
                        //return element.innerHTML;
                        return this.innerHTML;
                    }
                }
            }
            
            //No valid chunks produced
            else {
                //No valid chunks even when splitting by letter, time to move
                //on to the next node
                if (splitChar == '') {
                    this.applyEllipsis(target, '');
                    target = this.getLastChild(this.element);
                    this.reset();
                }
            }

            //If you get here it means still too big, let's keep truncating
            if (options.animate) {
                setTimeout(function () {
                    this.truncate(target, maxHeight);
                }, options.animate === true ? 10 : options.animate);
            }
            else {
                return this.truncate(target, maxHeight);
            }
        },
        
        /**
        * Resets global variables.
        */
        reset: function () {
            this.$.textPara.innerHTML = this.text;
            this.chunks = null;
            this.lastChunk = null;
        },
        
        applyEllipsis: function (elem, str) {
            elem.nodeValue = str + options.truncationChar;
        }   
    });
</script>
