/*
* Copyright (c) 2014 adenin TECHNOLOGIES. All rights reserved.
* This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
*
* based on Clamp.js 0.5.1
* Copyright 2011-2013, Joseph Schmitt http://joe.sh
* Released under the WTFPL license
* http://sam.zoy.org/wtfpl/
*/
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-core-theme/at-core-theme.html">
<dom-module id="at-carbon-clamp">
    <style>
		:host {
			position: relative;
			width: 100%;
			height: 100%;
			box-sizing: border-box;
			display: block;
		}

		.wrap{
			border : none;
            margin : 0;
            padding: 0;
            width  : auto;
            height : auto;
		}
	  
		#textPara {
			-webkit-transform: translateZ(0); /* hack to force Chrome to handle divs outside visible viewport correctly */
		}
    </style>
    <template>
        <at-core-theme></at-core-theme>
        <div id="clampWrapper" style="height:100%">
            <div id="textPara"></div>
        </div>
        <content></content>
    </template>
</dom-module>
<script>
    Polymer({
    	is : 'at-carbon-clamp',
    	_scopeCssViaAttr : true,
    	properties : {
    		text : {
    			type : String,
    			value : '',
    			reflect : true
    		},
    		lines : {
    			type : Number,
    			value : 1,
    			reflect : true
    		}
    	},

    	observers : [
    		'propChanged(text, lines)'
    	],
		
    	ellipsis: 'â€¦',

    	propChanged : function () {
			if(!this._afterReady)
			{
				return;
			}
			
			this.clampText();
    	},

		attached: function () {
            var that = this;
            window.addEventListener('resize', function (event) {
                that.clampText();
            }.bind(this));
        },
		
    	ready : function () {
			if (this.lines > 1) {
    			//Fix for non chrome browsers
    			if (navigator.userAgent.toLowerCase().indexOf('chrome') < 0) {
    				this.lines = this.lines + 1;
    			}
    		}
			
			var innerText = this.textContent.slice().trim();
            if(( this.text === undefined || this.text.length == 0) && (innerText.length > 0)){
                this.text = innerText;                
                for(var i=0; i<this.childNodes.length; i++)//Remove only text node from this.textContent
                {
                    if(this.childNodes[i].nodeType==3)//TEXT_NODE
                    {
                        this.removeChild(this.childNodes[i]);
                        i--;
                    }
                }
            }

    		this.clampText();
			
			this._afterReady = true;
    	},

    	clampText : function () {
    		this.debounce('clampText', function () {
    			this.$.textPara.style.width = '100%';
    			this.$.textPara.textContent = this.text;

    			if (this.lines === 1) {
    				this.$.textPara.style.textOverflow = 'ellipsis';
    				this.$.textPara.style.whiteSpace = 'nowrap';
    				this.$.textPara.style.overflow = 'hidden';
    			} else {
    			    this.lineHeight = this.getLineHeight(this.$.textPara)
    			    if (!this.lineHeight)
    			    {
    			        console.log("clampText: wait for lineHeight");
    			        this.async(function () {
    			            this.clampText();
    			        }, 100);
    			        return;
    			    }
                    
					this.truncate();
    			}

    		}, 50);
    	},

    	/**
    	 * Returns the line-height of an element as an integer.
    	 */
    	getLineHeight : function (elem) {
    		var lh = this.computeStyle(elem, 'line-height');
    		if (lh == 'normal') {
    			// Normal line heights vary from browser to browser. The spec recommends
    			// a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.
    			lh = parseInt(this.computeStyle(elem, 'font-size')) * 1.1;
    		}
    		return parseInt(lh);
    	},

    	/**
    	 * Return the current style for an element.
    	 * @param {HTMLElement} elem The element to compute.
    	 * @param {string} prop The style property.
    	 * @returns {number}
    	 */
    	computeStyle : function (elem, prop) {
    		if (!window.getComputedStyle) {
    			window.getComputedStyle = function (el, pseudo) {
    				this.el = el;
    				this.getPropertyValue = function (prop) {
    					var re = /(\-([a-z]){1})/g;
    					if (prop == 'float')
    						prop = 'styleFloat';
    					if (re.test(prop)) {
    						prop = prop.replace(re, function () {
    								return arguments[2].toUpperCase();
    							});
    					}
    					return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;
    				}
    				return this;
    			}
    		}

    		return window.getComputedStyle(elem, null).getPropertyValue(prop);
    	},

    	/* Public: Creates an instance of Truncate.
    	 *
    	 * element - A DOM element to be truncated.
    	 *
    	 * Examples:
    	 *
    	 *   var element = document.createElement('span');
    	 *   element.innerHTML = 'This is<br>odd.';
    	 *
    	 *   // Update HTML
    	 *   truncated.update('This is not very odd.');
    	 */
    	truncate : function () {
    		if (this.maxHeight === undefined) {
    			this.maxHeight = parseInt(this.lines, 10) * parseInt(this.lineHeight, 10);
    		}

    		this.original = this.cached = this.$.textPara.textContent;

    		this.update();
    	},

    	setText : function (element, text) {
    		if (element.innerText) {
    			element.innerText = text;
    		} else if (element.nodeValue) {
    			element.nodeValue = text;
    		} else if (element.textContent) {
    			element.textContent = text;
    		} else {
    			return false;
    		}
    	},
    	/* Truncates the text content of a node using binary search.
    	 * If no valid truncation point is found, attempt to truncate its nearest sibling.
    	 *
    	 * textNode - The node to truncate.
    	 * rootNode - The root node to measure the truncated height.
		 *
    	 * Returns true if truncation happened, false otherwise.
    	 */
    	truncateTextContent : function (element, rootNode) {
    		var original = element.textContent;

    		var maxChunk = '';
    		var mid,
    		chunk;
    		var low = 0;
    		var high = original.length;

    		// Binary Search
    		while (low <= high) {
    			mid = low + ((high - low) >> 1); // Integer division

    			chunk = original.substr(0, mid + 1).trim() + this.ellipsis;
    			this.setText(element, chunk);
				
				var rootNodeHeight = parseInt(this.computeStyle(rootNode, 'height'));
    			if (rootNodeHeight > this.maxHeight) {
    				high = mid - 1;
    			} else {
    				low = mid + 1;
    				maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;
    			}
    		}

    		if (maxChunk.length > 0) {
    			this.setText(element, maxChunk);
    			return true;
    		}
    	},
		
    	/* Public: Updates the inner HTML of the element and re-truncates. 
    	 *
    	 * textContent - The new textContent.
    	 *
    	 * Returns nothing.
    	 */
    	update: function (textContent) {
    	    // Update HTML if provided, otherwise use the current html and restore
    	    // the truncated content to the original if it's currently present.

    	    if (textContent) {
    	        this.original = this.$.textPara.innerHTML = textContent;
    	    } else if (this.$.textPara.innerHTML === this.cached) {
    	        this.$.textPara.innerHTML = this.original;
    	    }

    	    // Wrap the contents in order to ignore container's margin/padding.
    	    this.$.textPara.classList.add("wrap");

    	    // Check if already meets height requirement
    	    //console.log("clientHeight: " + this.$.textPara.clientHeight + " maxHeight: " + this.maxHeight);
    	    if (this.$.textPara.clientHeight > this.maxHeight) {
    	        this.truncateTextContent(this.$.textPara, this.$.textPara);
    	    }

    	    // Restore the wrapped contents
    	    this.$.textPara.classList.remove("wrap");

    	    // Cache the truncated content
    	    this.cached = this.$.textPara.innerHTML;

    	},
    });
</script>
